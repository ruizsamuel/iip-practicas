#BlueJ class context
comment0.target=Point
comment0.text=\ \ \r\n\ \ Clase\ Point\:\ clase\ "tipo\ de\ datos"\ que\ define\ un\ punto\ en\ el\ plano\ \r\n\ \ cartesiano,\ determinado\ por\ sus\ coordenadas\ x\ e\ y.\ \r\n\ \ \r\n\ \ @author\ IIP\ -\ Practica\ 5\r\n\ \ @version\ Curso\ 2021/22\r\n
comment1.params=
comment1.target=Point()
comment1.text=Crea\ un\ Point\ con\ abscisa\ 0.0\ y\ ordenada\ 0.0.
comment10.params=
comment10.target=java.lang.String\ toString()
comment10.text=\ Devuelve\ un\ String\ que\ representa\ el\ Point\ this\ en\ el\ \ \r\n\ \ formato\ tipico\ matematico,\ i.e.,\ (abscisa,ordenada)\ \r\n\ \ @return\ String,\ el\ resultado.\r\n
comment11.params=u\ v
comment11.target=int\ cross(Point,\ Point)
comment11.text=\ Dado\ el\ rayo\ que\ se\ inicia\ en\ this\ y\ avanza\ paralelo\ al\ eje\ X\ \r\n\ \ en\ sentido\ +,\ comprueba\ si\ dicho\ rayo\ cruza\ el\ segmento\ de\ \r\n\ \ recta\ uv,\ es\ decir,\ pasa\ por\ un\ unico\ punto\ del\ segmento.\r\n\ \ @param\ u\ Point,\ punto\ extremo\ del\ segmento\ de\ recta\ uv.\r\n\ \ @param\ v\ Point,\ punto\ extremo\ del\ segmento\ de\ recta\ uv.\r\n\ \ @return\ int,\ entero\ entre\ DONT_CROSS\ (-1),\ LOW_CROSS\ (0),\ \r\n\ \ CROSS\ (1),\ HIGH_CROSS\ (2),\ segun\ los\ casos\:\r\n\ \ -\ Si\ el\ rayo\ no\ cruza\ el\ segmento,\ devuelve\ DONT_CROSS.\r\n\ \ -\ Si\ el\ rayo\ lo\ cruza\ por\ el\ extremo\ mas\ bajo,\ devuelve\ LOW_CROSS.\r\n\ \ -\ Si\ el\ rayo\ lo\ cruza\ por\ un\ punto\ entre\ u\ y\ v,\ devuelve\ CROSS.\r\n\ \ -\ Si\ el\ rayo\ lo\ cruza\ por\ el\ extremo\ mas\ alto,\ devuelve\ HIGH_CROSS.\r\n
comment2.params=px\ py
comment2.target=Point(double,\ double)
comment2.text=\ Crea\ un\ Point\ con\ abscisa\ px\ y\ ordenada\ py.\ \r\n\ \ @param\ px\ double,\ la\ abscisa.\r\n\ \ @param\ py\ double,\ la\ ordenada.\r\n
comment3.params=
comment3.target=double\ getX()
comment3.text=\ Devuelve\ la\ abscisa\ del\ Point\ this.\ \r\n\ \ @return\ double,\ la\ abscisa.\ \ \ \ \ \ \r\n
comment4.params=
comment4.target=double\ getY()
comment4.text=\ Devuelve\ la\ ordenada\ del\ Point\ this.\r\n\ \ @return\ double,\ la\ ordenada.\r\n
comment5.params=px
comment5.target=void\ setX(double)
comment5.text=\ Actualiza\ la\ abscisa\ del\ Point\ this\ a\ px.\r\n\ \ @param\ px\ double,\ la\ nueva\ abscisa.\r\n
comment6.params=py
comment6.target=void\ setY(double)
comment6.text=\ Actualiza\ la\ ordenada\ del\ Point\ this\ a\ py.\ \r\n\ \ @param\ py\ double,\ la\ nueva\ ordenada.\r\n
comment7.params=p
comment7.target=double\ distance(Point)
comment7.text=\ Devuelve\ la\ distancia\ entre\ el\ Point\ this\ y\ otro\ Point\ dado.\r\n\ \ @param\ p\ Point,\ el\ otro\ Point.\r\n\ \ @return\ double,\ la\ distancia.\r\n
comment8.params=px\ py
comment8.target=void\ move(double,\ double)
comment8.text=\ Actualiza\ la\ abscisa\ del\ Point\ this\ a\ px\ y\ la\ ordenada\ a\ py.\r\n\ \ @param\ px\ double,\ la\ nueva\ abscisa.\r\n\ \ @param\ py\ double,\ la\ nueva\ ordenada.\r\n
comment9.params=o
comment9.target=boolean\ equals(java.lang.Object)
comment9.text=\r\n\ Comprueba\ si\ el\ Point\ this\ es\ igual\ a\ otro\ Point\ dado.\r\n\ @param\ o\ Object,\ objeto\ a\ comparar\ con\ el\ Point\ this.\r\n\ @return\ boolean,\ true\ si\ o\ es\ un\ Point\ y\ las\ coordenadas\r\n\ x\ e\ y\ del\ Point\ this\ coinciden\ con\ las\ del\ Point\ dado\ y\ \r\n\ false\ en\ caso\ contrario.\r\n
numComments=12
